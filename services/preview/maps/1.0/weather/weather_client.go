// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package weather

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// WeatherClient contains the methods for the Weather group.
// Don't use this type directly, use NewWeatherClient() instead.
type WeatherClient struct {
	con *Connection
	xmsClientID *string
}

// NewWeatherClient creates a new instance of WeatherClient with the specified values.
func NewWeatherClient(con *Connection, xmsClientID *string) *WeatherClient {
	return &WeatherClient{con: con, xmsClientID: xmsClientID}
}

// GetAirQualityDailyForecast - Get Air Quality Daily Forecast
// Applies to: S1 pricing tiers.
// The service provides the detailed information about the concentration of pollutant and overall status for upcoming few days air quality. The service
// can provide forecast air quality for future one to
// four days.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetAirQualityDailyForecast(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetAirQualityDailyForecastOptions) (WeatherGetAirQualityDailyForecastResponse, error) {
	req, err := client.getAirQualityDailyForecastCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return WeatherGetAirQualityDailyForecastResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetAirQualityDailyForecastResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetAirQualityDailyForecastResponse{}, client.getAirQualityDailyForecastHandleError(resp)
	}
	return client.getAirQualityDailyForecastHandleResponse(resp)
}

// getAirQualityDailyForecastCreateRequest creates the GetAirQualityDailyForecast request.
func (client *WeatherClient) getAirQualityDailyForecastCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetAirQualityDailyForecastOptions) (*azcore.Request, error) {
	urlPath := "/weather/airQuality/forecast/daily/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	reqQP.Set("query", query)
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAirQualityDailyForecastHandleResponse handles the GetAirQualityDailyForecast response.
func (client *WeatherClient) getAirQualityDailyForecastHandleResponse(resp *azcore.Response) (WeatherGetAirQualityDailyForecastResponse, error) {
	result := WeatherGetAirQualityDailyForecastResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.DailyAirQualityForecastResponse); err != nil {
		return WeatherGetAirQualityDailyForecastResponse{}, err
	}
	return result, nil
}

// getAirQualityDailyForecastHandleError handles the GetAirQualityDailyForecast error response.
func (client *WeatherClient) getAirQualityDailyForecastHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAirQualityHourlyForecast - Get Air Quality Hourly forecast
// Applies to: S1 pricing tiers.
// The service provides the detailed information about the concentration of pollutant and overall status for current air quality.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetAirQualityHourlyForecast(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetAirQualityHourlyForecastOptions) (WeatherGetAirQualityHourlyForecastResponse, error) {
	req, err := client.getAirQualityHourlyForecastCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return WeatherGetAirQualityHourlyForecastResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetAirQualityHourlyForecastResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetAirQualityHourlyForecastResponse{}, client.getAirQualityHourlyForecastHandleError(resp)
	}
	return client.getAirQualityHourlyForecastHandleResponse(resp)
}

// getAirQualityHourlyForecastCreateRequest creates the GetAirQualityHourlyForecast request.
func (client *WeatherClient) getAirQualityHourlyForecastCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetAirQualityHourlyForecastOptions) (*azcore.Request, error) {
	urlPath := "/weather/airQuality/forecast/hourly/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	reqQP.Set("query", query)
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.Pollutants != nil {
		reqQP.Set("pollutants", strconv.FormatBool(*options.Pollutants))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAirQualityHourlyForecastHandleResponse handles the GetAirQualityHourlyForecast response.
func (client *WeatherClient) getAirQualityHourlyForecastHandleResponse(resp *azcore.Response) (WeatherGetAirQualityHourlyForecastResponse, error) {
	result := WeatherGetAirQualityHourlyForecastResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.HourlyAirQualityForecastResponse); err != nil {
		return WeatherGetAirQualityHourlyForecastResponse{}, err
	}
	return result, nil
}

// getAirQualityHourlyForecastHandleError handles the GetAirQualityHourlyForecast error response.
func (client *WeatherClient) getAirQualityHourlyForecastHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetClimoSummary - Get Climo Month Summary
// Applies to: S0 and S1 pricing tiers.
// The service returns climatology data such as month summary for a given coordinate location.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetClimoSummary(ctx context.Context, formatParam ResponseFormat, query string, month string, options *WeatherGetClimoSummaryOptions) (WeatherGetClimoSummaryResponse, error) {
	req, err := client.getClimoSummaryCreateRequest(ctx, formatParam, query, month, options)
	if err != nil {
		return WeatherGetClimoSummaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetClimoSummaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetClimoSummaryResponse{}, client.getClimoSummaryHandleError(resp)
	}
	return client.getClimoSummaryHandleResponse(resp)
}

// getClimoSummaryCreateRequest creates the GetClimoSummary request.
func (client *WeatherClient) getClimoSummaryCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, month string, options *WeatherGetClimoSummaryOptions) (*azcore.Request, error) {
	urlPath := "/weather/climo/summary/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	reqQP.Set("month", month)
	if options != nil && options.Unit != nil {
		reqQP.Set("unit", string(*options.Unit))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getClimoSummaryHandleResponse handles the GetClimoSummary response.
func (client *WeatherClient) getClimoSummaryHandleResponse(resp *azcore.Response) (WeatherGetClimoSummaryResponse, error) {
	result := WeatherGetClimoSummaryResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.ClimoSummaryResponse); err != nil {
		return WeatherGetClimoSummaryResponse{}, err
	}
	return result, nil
}

// getClimoSummaryHandleError handles the GetClimoSummary error response.
func (client *WeatherClient) getClimoSummaryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCurrentAirQuality - Get Current Air Quality
// Applies to: S0 and S1 pricing tiers.
// The service provides the detailed information about the concentration of pollutant and overall status for current air quality.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetCurrentAirQuality(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetCurrentAirQualityOptions) (WeatherGetCurrentAirQualityResponse, error) {
	req, err := client.getCurrentAirQualityCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return WeatherGetCurrentAirQualityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetCurrentAirQualityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetCurrentAirQualityResponse{}, client.getCurrentAirQualityHandleError(resp)
	}
	return client.getCurrentAirQualityHandleResponse(resp)
}

// getCurrentAirQualityCreateRequest creates the GetCurrentAirQuality request.
func (client *WeatherClient) getCurrentAirQualityCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetCurrentAirQualityOptions) (*azcore.Request, error) {
	urlPath := "/weather/airQuality/current/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	reqQP.Set("query", query)
	if options != nil && options.Pollutants != nil {
		reqQP.Set("pollutants", strconv.FormatBool(*options.Pollutants))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCurrentAirQualityHandleResponse handles the GetCurrentAirQuality response.
func (client *WeatherClient) getCurrentAirQualityHandleResponse(resp *azcore.Response) (WeatherGetCurrentAirQualityResponse, error) {
	result := WeatherGetCurrentAirQualityResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.CurrentAirQualityResponse); err != nil {
		return WeatherGetCurrentAirQualityResponse{}, err
	}
	return result, nil
}

// getCurrentAirQualityHandleError handles the GetCurrentAirQuality error response.
func (client *WeatherClient) getCurrentAirQualityHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCurrentConditions - Get Current Conditions
// Applies to: S0 and S1 pricing tiers.
// Get Current Conditions service returns detailed current weather conditions such as precipitation, temperature and wind for a given coordinate location.
// Also, observations from the past 6 or 24 hours
// for a particular location can be retrieved. The basic information returned with the response include details such as observation date and time, brief
// description of the weather conditions, weather
// icon, precipitation indicator flags, and temperature. Additional details such as RealFeelâ„¢ Temperature and UV index are also returned.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetCurrentConditions(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetCurrentConditionsOptions) (WeatherGetCurrentConditionsResponse, error) {
	req, err := client.getCurrentConditionsCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return WeatherGetCurrentConditionsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetCurrentConditionsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetCurrentConditionsResponse{}, client.getCurrentConditionsHandleError(resp)
	}
	return client.getCurrentConditionsHandleResponse(resp)
}

// getCurrentConditionsCreateRequest creates the GetCurrentConditions request.
func (client *WeatherClient) getCurrentConditionsCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetCurrentConditionsOptions) (*azcore.Request, error) {
	urlPath := "/weather/currentConditions/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Unit != nil {
		reqQP.Set("unit", string(*options.Unit))
	}
	if options != nil && options.Details != nil {
		reqQP.Set("details", *options.Details)
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCurrentConditionsHandleResponse handles the GetCurrentConditions response.
func (client *WeatherClient) getCurrentConditionsHandleResponse(resp *azcore.Response) (WeatherGetCurrentConditionsResponse, error) {
	result := WeatherGetCurrentConditionsResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.CurrentConditionsResponse); err != nil {
		return WeatherGetCurrentConditionsResponse{}, err
	}
	return result, nil
}

// getCurrentConditionsHandleError handles the GetCurrentConditions error response.
func (client *WeatherClient) getCurrentConditionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDailyClimoActuals - Get Daily Climo Actuals
// Applies to: S0 and S1 pricing tiers.
// The service returns climatology data such as past daily actuals for a given coordinate location.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetDailyClimoActuals(ctx context.Context, formatParam ResponseFormat, query string, start string, options *WeatherGetDailyClimoActualsOptions) (WeatherGetDailyClimoActualsResponse, error) {
	req, err := client.getDailyClimoActualsCreateRequest(ctx, formatParam, query, start, options)
	if err != nil {
		return WeatherGetDailyClimoActualsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetDailyClimoActualsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetDailyClimoActualsResponse{}, client.getDailyClimoActualsHandleError(resp)
	}
	return client.getDailyClimoActualsHandleResponse(resp)
}

// getDailyClimoActualsCreateRequest creates the GetDailyClimoActuals request.
func (client *WeatherClient) getDailyClimoActualsCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, start string, options *WeatherGetDailyClimoActualsOptions) (*azcore.Request, error) {
	urlPath := "/weather/climo/actuals/daily/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	reqQP.Set("start", start)
	if options != nil && options.Unit != nil {
		reqQP.Set("unit", string(*options.Unit))
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDailyClimoActualsHandleResponse handles the GetDailyClimoActuals response.
func (client *WeatherClient) getDailyClimoActualsHandleResponse(resp *azcore.Response) (WeatherGetDailyClimoActualsResponse, error) {
	result := WeatherGetDailyClimoActualsResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.DailyClimoActualsResponse); err != nil {
		return WeatherGetDailyClimoActualsResponse{}, err
	}
	return result, nil
}

// getDailyClimoActualsHandleError handles the GetDailyClimoActuals error response.
func (client *WeatherClient) getDailyClimoActualsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDailyClimoNormals - Get Daily Climo Normals
// Applies to: S0 and S1 pricing tiers.
// The service returns climatology data such as past daily normals for a given coordinate location.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetDailyClimoNormals(ctx context.Context, formatParam ResponseFormat, query string, start string, options *WeatherGetDailyClimoNormalsOptions) (WeatherGetDailyClimoNormalsResponse, error) {
	req, err := client.getDailyClimoNormalsCreateRequest(ctx, formatParam, query, start, options)
	if err != nil {
		return WeatherGetDailyClimoNormalsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetDailyClimoNormalsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetDailyClimoNormalsResponse{}, client.getDailyClimoNormalsHandleError(resp)
	}
	return client.getDailyClimoNormalsHandleResponse(resp)
}

// getDailyClimoNormalsCreateRequest creates the GetDailyClimoNormals request.
func (client *WeatherClient) getDailyClimoNormalsCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, start string, options *WeatherGetDailyClimoNormalsOptions) (*azcore.Request, error) {
	urlPath := "/weather/climo/normals/daily/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	reqQP.Set("start", start)
	if options != nil && options.Unit != nil {
		reqQP.Set("unit", string(*options.Unit))
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDailyClimoNormalsHandleResponse handles the GetDailyClimoNormals response.
func (client *WeatherClient) getDailyClimoNormalsHandleResponse(resp *azcore.Response) (WeatherGetDailyClimoNormalsResponse, error) {
	result := WeatherGetDailyClimoNormalsResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.DailyClimoNormalsResponse); err != nil {
		return WeatherGetDailyClimoNormalsResponse{}, err
	}
	return result, nil
}

// getDailyClimoNormalsHandleError handles the GetDailyClimoNormals error response.
func (client *WeatherClient) getDailyClimoNormalsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDailyClimoRecords - Get Daily Climo Records
// Applies to: S0 and S1 pricing tiers.
// The service returns climatology data such as past daily records for a given coordinate location.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetDailyClimoRecords(ctx context.Context, formatParam ResponseFormat, query string, start string, options *WeatherGetDailyClimoRecordsOptions) (WeatherGetDailyClimoRecordsResponse, error) {
	req, err := client.getDailyClimoRecordsCreateRequest(ctx, formatParam, query, start, options)
	if err != nil {
		return WeatherGetDailyClimoRecordsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetDailyClimoRecordsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetDailyClimoRecordsResponse{}, client.getDailyClimoRecordsHandleError(resp)
	}
	return client.getDailyClimoRecordsHandleResponse(resp)
}

// getDailyClimoRecordsCreateRequest creates the GetDailyClimoRecords request.
func (client *WeatherClient) getDailyClimoRecordsCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, start string, options *WeatherGetDailyClimoRecordsOptions) (*azcore.Request, error) {
	urlPath := "/weather/climo/records/daily/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	reqQP.Set("start", start)
	if options != nil && options.Unit != nil {
		reqQP.Set("unit", string(*options.Unit))
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDailyClimoRecordsHandleResponse handles the GetDailyClimoRecords response.
func (client *WeatherClient) getDailyClimoRecordsHandleResponse(resp *azcore.Response) (WeatherGetDailyClimoRecordsResponse, error) {
	result := WeatherGetDailyClimoRecordsResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.DailyClimoRecordsResponse); err != nil {
		return WeatherGetDailyClimoRecordsResponse{}, err
	}
	return result, nil
}

// getDailyClimoRecordsHandleError handles the GetDailyClimoRecords error response.
func (client *WeatherClient) getDailyClimoRecordsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDailyForecast - Get Daily Forecast
// Applies to: S0 and S1 pricing tiers.
// The service returns detailed weather forecast such as temperature and wind by day for the next 1, 5, 10, 15, 25, or 45 days for a given coordinate location.
// The response include details such as
// temperature, wind, precipitation, air quality, and UV index.
// In S0 you can request daily forecast for the next 1, 5, 10, and 15 days. In S1 you can also request daily forecast for the next 25 days, and 45 days.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetDailyForecast(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetDailyForecastOptions) (WeatherGetDailyForecastResponse, error) {
	req, err := client.getDailyForecastCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return WeatherGetDailyForecastResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetDailyForecastResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetDailyForecastResponse{}, client.getDailyForecastHandleError(resp)
	}
	return client.getDailyForecastHandleResponse(resp)
}

// getDailyForecastCreateRequest creates the GetDailyForecast request.
func (client *WeatherClient) getDailyForecastCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetDailyForecastOptions) (*azcore.Request, error) {
	urlPath := "/weather/forecast/daily/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Unit != nil {
		reqQP.Set("unit", string(*options.Unit))
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDailyForecastHandleResponse handles the GetDailyForecast response.
func (client *WeatherClient) getDailyForecastHandleResponse(resp *azcore.Response) (WeatherGetDailyForecastResponse, error) {
	result := WeatherGetDailyForecastResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.DailyForecastResponse); err != nil {
		return WeatherGetDailyForecastResponse{}, err
	}
	return result, nil
}

// getDailyForecastHandleError handles the GetDailyForecast error response.
func (client *WeatherClient) getDailyForecastHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDailyIndices - Get Daily Indices
// Applies to: S0 and S1 pricing tiers.
// There may be times when you want to know if the weather conditions are optimal for a specific activity, for example, for outdoor construction, indoor
// activities, running or farming including soil
// moisture information. Azure Maps Indices API returns index values that will guide end users to plan future activities. For example, a health mobile application
// can notify users that today is good
// weather for running or for other outdoors activities like for playing golf, and retail stores can optimize their digital marketing campaigns based on
// predicted index values. The service returns in
// daily indices values for current and next 5, 10 and 15 days starting from current day.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetDailyIndices(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetDailyIndicesOptions) (WeatherGetDailyIndicesResponse, error) {
	req, err := client.getDailyIndicesCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return WeatherGetDailyIndicesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetDailyIndicesResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetDailyIndicesResponse{}, client.getDailyIndicesHandleError(resp)
	}
	return client.getDailyIndicesHandleResponse(resp)
}

// getDailyIndicesCreateRequest creates the GetDailyIndices request.
func (client *WeatherClient) getDailyIndicesCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetDailyIndicesOptions) (*azcore.Request, error) {
	urlPath := "/weather/indices/daily/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.IndexID != nil {
		reqQP.Set("indexId", strconv.FormatInt(int64(*options.IndexID), 10))
	}
	if options != nil && options.IndexGroupID != nil {
		reqQP.Set("indexGroupId", strconv.FormatInt(int64(*options.IndexGroupID), 10))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDailyIndicesHandleResponse handles the GetDailyIndices response.
func (client *WeatherClient) getDailyIndicesHandleResponse(resp *azcore.Response) (WeatherGetDailyIndicesResponse, error) {
	result := WeatherGetDailyIndicesResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.DailyIndicesResponse); err != nil {
		return WeatherGetDailyIndicesResponse{}, err
	}
	return result, nil
}

// getDailyIndicesHandleError handles the GetDailyIndices error response.
func (client *WeatherClient) getDailyIndicesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetHourlyForecast - Get Hourly Forecast
// Applies to: S0 and S1 pricing tiers.
// Request detailed weather forecast by the hour for the next 1, 12, 24 (1 day), 72 (3 days), 120 (5 days), and 240 hours (10 days) for the given the given
// coordinate location. The API returns details
// such as temperature, humidity, wind, precipitation, and ultraviolet (UV) index.
// In S0 you can request hourly forecast for the next 1, 12, 24 hours (1 day), and 72 hours (3 days). In S1 you can also request hourly forecast for the
// next 120 (5 days) and 240 hours (10 days).
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetHourlyForecast(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetHourlyForecastOptions) (WeatherGetHourlyForecastResponse, error) {
	req, err := client.getHourlyForecastCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return WeatherGetHourlyForecastResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetHourlyForecastResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetHourlyForecastResponse{}, client.getHourlyForecastHandleError(resp)
	}
	return client.getHourlyForecastHandleResponse(resp)
}

// getHourlyForecastCreateRequest creates the GetHourlyForecast request.
func (client *WeatherClient) getHourlyForecastCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetHourlyForecastOptions) (*azcore.Request, error) {
	urlPath := "/weather/forecast/hourly/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Unit != nil {
		reqQP.Set("unit", string(*options.Unit))
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getHourlyForecastHandleResponse handles the GetHourlyForecast response.
func (client *WeatherClient) getHourlyForecastHandleResponse(resp *azcore.Response) (WeatherGetHourlyForecastResponse, error) {
	result := WeatherGetHourlyForecastResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.HourlyForecastResponse); err != nil {
		return WeatherGetHourlyForecastResponse{}, err
	}
	return result, nil
}

// getHourlyForecastHandleError handles the GetHourlyForecast error response.
func (client *WeatherClient) getHourlyForecastHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetMinuteForecast - Get Minute Forecast
// Applies to: S1 pricing tier.
// Get Minute Forecast service returns minute-by-minute forecasts for a given location for the next 120 minutes. Users can request weather forecasts in
// the interval of 1, 5 and 15 minutes. The response
// will include details such as the type of precipitation (including rain, snow, or a mixture of both), start time, and precipitation intensity value (dBZ).
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetMinuteForecast(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetMinuteForecastOptions) (WeatherGetMinuteForecastResponse, error) {
	req, err := client.getMinuteForecastCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return WeatherGetMinuteForecastResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetMinuteForecastResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetMinuteForecastResponse{}, client.getMinuteForecastHandleError(resp)
	}
	return client.getMinuteForecastHandleResponse(resp)
}

// getMinuteForecastCreateRequest creates the GetMinuteForecast request.
func (client *WeatherClient) getMinuteForecastCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetMinuteForecastOptions) (*azcore.Request, error) {
	urlPath := "/weather/forecast/minute/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Interval != nil {
		reqQP.Set("interval", strconv.FormatInt(int64(*options.Interval), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMinuteForecastHandleResponse handles the GetMinuteForecast response.
func (client *WeatherClient) getMinuteForecastHandleResponse(resp *azcore.Response) (WeatherGetMinuteForecastResponse, error) {
	result := WeatherGetMinuteForecastResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.MinuteForecastResponse); err != nil {
		return WeatherGetMinuteForecastResponse{}, err
	}
	return result, nil
}

// getMinuteForecastHandleError handles the GetMinuteForecast error response.
func (client *WeatherClient) getMinuteForecastHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetQuarterDayForecast - Get Quarter-Day Forecast
// Applies to: S0 and S1 pricing tiers.
// Service returns detailed weather forecast by quarter-day for the next 1, 5, 10, or 15 days for a given location. Response data is presented by quarters
// of the day - morning, afternoon, evening, and
// overnight. Details such as temperature, humidity, wind, precipitation, and UV index are returned.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetQuarterDayForecast(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetQuarterDayForecastOptions) (WeatherGetQuarterDayForecastResponse, error) {
	req, err := client.getQuarterDayForecastCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return WeatherGetQuarterDayForecastResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetQuarterDayForecastResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetQuarterDayForecastResponse{}, client.getQuarterDayForecastHandleError(resp)
	}
	return client.getQuarterDayForecastHandleResponse(resp)
}

// getQuarterDayForecastCreateRequest creates the GetQuarterDayForecast request.
func (client *WeatherClient) getQuarterDayForecastCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetQuarterDayForecastOptions) (*azcore.Request, error) {
	urlPath := "/weather/forecast/quarterDay/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Unit != nil {
		reqQP.Set("unit", string(*options.Unit))
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getQuarterDayForecastHandleResponse handles the GetQuarterDayForecast response.
func (client *WeatherClient) getQuarterDayForecastHandleResponse(resp *azcore.Response) (WeatherGetQuarterDayForecastResponse, error) {
	result := WeatherGetQuarterDayForecastResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.QuarterDayForecastResponse); err != nil {
		return WeatherGetQuarterDayForecastResponse{}, err
	}
	return result, nil
}

// getQuarterDayForecastHandleError handles the GetQuarterDayForecast error response.
func (client *WeatherClient) getQuarterDayForecastHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSevereWeatherAlerts - Get Severe Weather Alerts
// Applies to: S0 and S1 pricing tiers.
// Severe weather phenomenon can significantly impact our everyday life and business operations. For example, severe weather conditions such as tropical
// storms, high winds or flooding can close roads and
// force logistics companies to reroute their fleet causing delays in reaching destinations and breaking the cold chain of refrigerated food products. Azure
// Maps Severe Weather Alerts API returns the
// severe weather alerts that are available worldwide from both official Government Meteorological Agencies and leading global to regional weather alert
// providers. The service can return details such as
// alert type, category, level and detailed description about the active severe alerts for the requested location, like hurricanes, thunderstorms, lightning,
// heat waves or forest fires.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetSevereWeatherAlerts(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetSevereWeatherAlertsOptions) (WeatherGetSevereWeatherAlertsResponse, error) {
	req, err := client.getSevereWeatherAlertsCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return WeatherGetSevereWeatherAlertsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetSevereWeatherAlertsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetSevereWeatherAlertsResponse{}, client.getSevereWeatherAlertsHandleError(resp)
	}
	return client.getSevereWeatherAlertsHandleResponse(resp)
}

// getSevereWeatherAlertsCreateRequest creates the GetSevereWeatherAlerts request.
func (client *WeatherClient) getSevereWeatherAlertsCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetSevereWeatherAlertsOptions) (*azcore.Request, error) {
	urlPath := "/weather/severe/alerts/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.Details != nil {
		reqQP.Set("details", *options.Details)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSevereWeatherAlertsHandleResponse handles the GetSevereWeatherAlerts response.
func (client *WeatherClient) getSevereWeatherAlertsHandleResponse(resp *azcore.Response) (WeatherGetSevereWeatherAlertsResponse, error) {
	result := WeatherGetSevereWeatherAlertsResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.SevereWeatherAlertsResponse); err != nil {
		return WeatherGetSevereWeatherAlertsResponse{}, err
	}
	return result, nil
}

// getSevereWeatherAlertsHandleError handles the GetSevereWeatherAlerts error response.
func (client *WeatherClient) getSevereWeatherAlertsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetWeatherAlongRoute - Get Weather along route
// Applies to: S1 pricing tier.
// Weather along a route API returns hyper local (one kilometer or less), up-to-the-minute weather nowcasts, weather hazard assessments, and notifications
// along a route described as a sequence of
// waypoints. This includes a list of weather hazards affecting the waypoint or route, and the aggregated hazard index for each waypoint might be used to
// paint each portion of a route according to how
// safe it is for the driver. When submitting the waypoints, it is recommended to stay within, or close to, the distance that can be traveled within 120-mins
// or shortly after. Data is updated every five
// minutes.
// The service supplements Azure Maps Route Service [https://docs.microsoft.com/rest/api/maps/route] that allows you to first request a route between an
// origin and a destination and use that as an input
// for Weather Along Route endpoint.
// In addition, the service supports scenarios to generate weather notifications for waypoints that experience an increase in intensity of a weather hazard.
// For example, if the vehicle is expected to
// begin experiencing heavy rain as it reaches a waypoint, a weather notification for heavy rain will be generated for that waypoint allowing the end product
// to display a heavy rain notification before
// the driver reaches that waypoint. The trigger for when to display the notification for a waypoint could be based, for example, on a geofence
// [https://docs.microsoft.com/azure/azure-maps/tutorial-iot-hub-maps], or selectable distance to the waypoint.
// The API covers all regions of the planet except latitudes above Greenland and Antarctica.
// If the operation fails it returns the *ErrorResponse error type.
func (client *WeatherClient) GetWeatherAlongRoute(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetWeatherAlongRouteOptions) (WeatherGetWeatherAlongRouteResponse, error) {
	req, err := client.getWeatherAlongRouteCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return WeatherGetWeatherAlongRouteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherGetWeatherAlongRouteResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherGetWeatherAlongRouteResponse{}, client.getWeatherAlongRouteHandleError(resp)
	}
	return client.getWeatherAlongRouteHandleResponse(resp)
}

// getWeatherAlongRouteCreateRequest creates the GetWeatherAlongRoute request.
func (client *WeatherClient) getWeatherAlongRouteCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetWeatherAlongRouteOptions) (*azcore.Request, error) {
	urlPath := "/weather/route/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getWeatherAlongRouteHandleResponse handles the GetWeatherAlongRoute response.
func (client *WeatherClient) getWeatherAlongRouteHandleResponse(resp *azcore.Response) (WeatherGetWeatherAlongRouteResponse, error) {
	result := WeatherGetWeatherAlongRouteResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.WeatherAlongRouteResponse); err != nil {
		return WeatherGetWeatherAlongRouteResponse{}, err
	}
	return result, nil
}

// getWeatherAlongRouteHandleError handles the GetWeatherAlongRoute error response.
func (client *WeatherClient) getWeatherAlongRouteHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

